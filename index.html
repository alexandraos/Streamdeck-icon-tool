<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Deck Icon Creator</title>
    <!-- Tailwind CSS for layout -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Phosphor Icons for UI icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    
    <style>
        /* Custom UI Styling to match the 'Dark/Pro' aesthetic */
        body {
            background-color: #121212;
            color: #e0e0e0;
            font-family: 'Inter', sans-serif;
            user-select: none; /* Prevent selection while dragging */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }

        /* Input Styling */
        input[type="color"] {
            -webkit-appearance: none; border: none; width: 32px; height: 32px;
            border-radius: 50%; overflow: hidden; cursor: pointer; padding: 0; background: none;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: 2px solid #444; border-radius: 50%; }

        input[type="range"] {
            -webkit-appearance: none; background: #333; height: 6px; border-radius: 3px; outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px; background: #3b82f6; border-radius: 50%; cursor: pointer;
        }

        /* Accordion transitions */
        .accordion-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            max-height: 0; opacity: 0; overflow: hidden;
        }
        .accordion-content.open { max-height: 600px; opacity: 1; }

        /* Canvas Checkerboard Background */
        .checkerboard {
            background-color: #1a1a1a;
            background-image: 
                linear-gradient(45deg, #222 25%, transparent 25%), 
                linear-gradient(-45deg, #222 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #222 75%), 
                linear-gradient(-45deg, transparent 75%, #222 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        /* Keyframes for the RGB Animation */
        @keyframes rotateHue {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(360deg); }
        }
        .animate-rgb { animation: rotateHue 6s linear infinite; }
        .drop-zone { border: 2px dashed #444; transition: all 0.2s; }
        .drop-zone.dragover { border-color: #3b82f6; background-color: rgba(59, 130, 246, 0.1); }

        /* Gizmo Cursors */
        .cursor-move { cursor: move; }
        .cursor-nwse { cursor: nwse-resize; }
        .cursor-nesw { cursor: nesw-resize; }
        .cursor-rotate { cursor: alias; } /* Closest valid generic cursor for rotation */

        /* Icon Result Styling */
        .icon-result {
            width: 48px; height: 48px; 
            padding: 8px; /* Inner padding */
            background-color: #1e1e1e; 
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-result:hover {
            background-color: #3b82f6;
            border-color: #3b82f6;
            transform: scale(1.05);
        }
        .icon-result svg {
            width: 100%; height: 100%;
            fill: #e0e0e0; /* Default color for search previews */
        }
        
        .loading-icon {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="h-screen flex flex-col md:flex-row overflow-hidden">

    <!-- LEFT SIDE: Controls -->
    <div class="w-full md:w-96 bg-[#1a1a1a] border-r border-[#333] flex flex-col h-full z-10 shadow-xl">
        <div class="p-4 border-b border-[#333] flex items-center justify-between">
            <h1 class="text-xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">
                Icon Forge
            </h1>
            <span class="text-xs text-gray-500">v1.1 Gizmos & Search</span>
        </div>

        <div class="flex-1 overflow-y-auto p-4 space-y-4">

            <!-- BORDER SECTION -->
            <div class="bg-[#222] rounded-lg p-1 border border-[#333]">
                <button onclick="toggleAccordion('border-controls')" class="w-full p-3 flex items-center justify-between hover:bg-[#2a2a2a] rounded transition">
                    <span class="font-medium flex items-center gap-2"><i class="ph ph-corners-out"></i> Border</span>
                    <i class="ph ph-caret-down text-gray-500"></i>
                </button>
                <div id="border-controls" class="accordion-content open px-3 pb-3">
                    <div class="space-y-4 mt-2">
                        <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Width</label>
                            <input type="range" id="borderWidth" min="0" max="20" value="8" class="w-32">
                        </div>
                        <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Radius</label>
                            <input type="range" id="borderRadius" min="0" max="72" value="24" class="w-32">
                        </div>
                        <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Style</label>
                            <select id="borderStyle" class="bg-[#333] text-sm rounded px-2 py-1 border border-[#444] focus:border-blue-500 outline-none">
                                <option value="solid">Solid</option>
                                <option value="gradient">Gradient</option>
                                <option value="rgb" selected>Slow RGB (Anim)</option>
                            </select>
                        </div>
                        <div class="flex items-center gap-4">
                            <div class="flex flex-col items-center">
                                <input type="color" id="borderColor1" value="#ff4d4d">
                                <span class="text-[10px] text-gray-500 mt-1">Col 1</span>
                            </div>
                            <div class="flex flex-col items-center">
                                <input type="color" id="borderColor2" value="#4d4dff">
                                <span class="text-[10px] text-gray-500 mt-1">Col 2</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ICON SECTION -->
            <div class="bg-[#222] rounded-lg p-1 border border-[#333]">
                <button onclick="toggleAccordion('icon-controls')" class="w-full p-3 flex items-center justify-between hover:bg-[#2a2a2a] rounded transition">
                    <span class="font-medium flex items-center gap-2"><i class="ph ph-image"></i> Icon</span>
                    <i class="ph ph-caret-down text-gray-500"></i>
                </button>
                <div id="icon-controls" class="accordion-content open px-3 pb-3">
                    <div class="space-y-4 mt-2">
                        
                        <!-- ICONIFY SEARCH BAR (New) -->
                        <div class="relative mb-4">
                            <input type="text" id="iconSearchInput" placeholder="Search Iconify (e.g., 'home', 'settings')" 
                                class="w-full p-2 pl-10 bg-[#333] border border-[#444] rounded-lg text-sm focus:border-blue-500 outline-none" autocomplete="off">
                            <i class="ph ph-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-gray-500"></i>
                        </div>

                        <!-- Search Results Container (New) -->
                        <div id="iconSearchResults" class="max-h-48 overflow-y-auto p-2 bg-[#2a2a2a] rounded-lg hidden">
                            <p id="searchMessage" class="text-sm text-gray-500 text-center py-2">Start typing to see results...</p>
                            <!-- Icons will be injected here -->
                            <div id="iconResultsGrid" class="grid grid-cols-5 gap-2 justify-items-center"></div>
                        </div>
                        
                        <!-- Upload Area -->
                        <div id="dropZone" class="drop-zone rounded-lg p-4 text-center cursor-pointer hover:bg-[#2a2a2a] mt-4">
                            <input type="file" id="iconUpload" class="hidden" accept="image/svg+xml,image/png,image/jpeg,image/webp">
                            <i class="ph ph-upload-simple text-2xl text-gray-400 mb-1"></i>
                            <p class="text-xs text-gray-400">Click or Drag SVG/PNG to upload</p>
                        </div>

                         <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Manual Scale</label>
                            <input type="range" id="iconScale" min="0.1" max="2" step="0.1" value="0.6" class="w-32">
                        </div>

                        <!-- Override Color Toggle -->
                        <div class="flex items-center justify-between pt-2 border-t border-[#333]">
                            <label class="text-sm text-gray-400">Override Color</label>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="overrideColorToggle" class="sr-only peer">
                                <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                        </div>

                        <div id="iconColorControl" class="flex items-center gap-4 transition-opacity opacity-50 pointer-events-none">
                            <div class="flex flex-col items-center">
                                <input type="color" id="iconColor" value="#ffffff">
                                <span class="text-[10px] text-gray-500 mt-1">Tint</span>
                            </div>
                            <p class="text-[10px] text-gray-500 w-32 leading-tight">Enable "Override Color" to tint PNGs or SVG paths.</p>
                        </div>

                        <div class="pt-2">
                             <button id="resetTransformBtn" class="text-xs text-blue-400 hover:text-blue-300 flex items-center gap-1">
                                <i class="ph ph-arrow-counter-clockwise"></i> Reset Position
                            </button>
                        </div>

                    </div>
                </div>
            </div>

            <!-- BACKGROUND SECTION -->
            <div class="bg-[#222] rounded-lg p-1 border border-[#333]">
                <button onclick="toggleAccordion('bg-controls')" class="w-full p-3 flex items-center justify-between hover:bg-[#2a2a2a] rounded transition">
                    <span class="font-medium flex items-center gap-2"><i class="ph ph-paint-bucket"></i> Background</span>
                    <i class="ph ph-caret-down text-gray-500"></i>
                </button>
                <div id="bg-controls" class="accordion-content open px-3 pb-3">
                    <div class="space-y-4 mt-2">
                        <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Color</label>
                            <input type="color" id="bgColor" value="#000000">
                        </div>

                         <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Corner Fill</label>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="cornerFillToggle" class="sr-only peer" checked>
                                <div class="w-9 h-5 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                        
                         <div class="flex items-center justify-between">
                            <label class="text-sm text-gray-400">Corner Color</label>
                            <input type="color" id="cornerColor" value="#ffffff">
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <div class="p-4 border-t border-[#333] bg-[#1a1a1a]">
            <button id="downloadBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-3 px-4 rounded-lg transition flex items-center justify-center gap-2 shadow-lg shadow-blue-900/20">
                <i class="ph ph-download-simple text-lg"></i>
                Download PNG
            </button>
        </div>
    </div>

    <!-- RIGHT SIDE: Preview -->
    <div class="flex-1 bg-[#0a0a0a] flex flex-col items-center justify-center relative p-8 checkerboard">
        
        <div class="absolute top-4 right-4 text-gray-500 text-sm flex gap-2 items-center">
             <span class="flex items-center gap-1 text-xs bg-black/50 px-2 py-1 rounded border border-white/10"><i class="ph ph-hand-pointing"></i> Drag to Move</span>
             <span class="flex items-center gap-1 text-xs bg-black/50 px-2 py-1 rounded border border-white/10"><i class="ph ph-arrows-out"></i> Gizmos Active</span>
        </div>

        <!-- THE MAIN SVG CANVAS -->
        <div id="canvasContainer" class="relative shadow-2xl shadow-black">
            <!-- Render at Retina 2x for display, download handles native res -->
            <svg id="mainSvg" width="288" height="288" viewBox="0 0 144 144" xmlns="http://www.w3.org/2000/svg" class="w-[288px] h-[288px] md:w-[400px] md:h-[400px]">
                <defs>
                    <linearGradient id="mainGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop id="stop1" offset="0%" stop-color="#ff4d4d" />
                        <stop id="stop2" offset="100%" stop-color="#4d4dff" />
                    </linearGradient>

                    <!-- Filter to recolor Raster Images (PNGs) to a single color -->
                    <!-- Updated matrix to properly flatten alpha to the flood color -->
                    <filter id="colorizeFilter">
                         <feColorMatrix type="matrix" values="0 0 0 0 1  0 0 0 0 1  0 0 0 0 1  0 0 0 1 0" result="whiteMask"/>
                         <feFlood id="floodColor" flood-color="#ffffff" result="flood"/>
                         <feComposite in="flood" in2="whiteMask" operator="in"/>
                    </filter>
                    
                    <clipPath id="cornerRadiusClip">
                        <rect x="0" y="0" width="144" height="144" rx="24" />
                    </clipPath>
                </defs>

                <!-- 1. Background -->
                <rect id="bgRect" x="0" y="0" width="144" height="144" fill="#000000" rx="24" />

                <!-- 2. Border -->
                <rect id="borderRect" x="4" y="4" width="136" height="136" fill="none" stroke="url(#mainGradient)" stroke-width="8" rx="20" />

                <!-- 3. Icon Container (Group) -->
                <!-- We wrap it in a 'transformGroup' to handle x,y,rotate easily -->
                <g id="transformGroup" transform="translate(72, 72) rotate(0) scale(0.6)">
                    <g id="iconGroup">
                        <!-- Default Icon -->
                        <g id="defaultIcon" fill="#ffffff">
                            <path d="M0 -30 L30 0 L0 30 L-30 0 Z" opacity="0.8"/>
                            <circle cx="0" cy="0" r="15" fill="none" stroke="currentColor" stroke-width="5"/>
                        </g>
                    </g>
                </g>

                <!-- 4. Corner Fill (Triangle) -->
                <path id="cornerPath" d="M100 144 L144 144 L144 100 Z" fill="#ffffff" clip-path="url(#cornerRadiusClip)" />
                
                <!-- 5. Gizmo Layer (Visual Only, removed on export) -->
                <!-- Draws ON TOP of everything -->
                <g id="gizmoLayer" display="none">
                    <!-- Snap Guides -->
                    <line id="snapX" x1="72" y1="0" x2="72" y2="144" stroke="cyan" stroke-width="1" stroke-dasharray="2,2" opacity="0" />
                    <line id="snapY" x1="0" y1="72" x2="144" y2="72" stroke="cyan" stroke-width="1" stroke-dasharray="2,2" opacity="0" />

                    <!-- Bounding Box -->
                    <rect id="gizmoBox" x="-50" y="-50" width="100" height="100" fill="none" stroke="#3b82f6" stroke-width="1" stroke-dasharray="4,2" />
                    
                    <!-- Resize Handles -->
                    <circle class="cursor-nwse gizmo-handle" data-type="scale" cx="-50" cy="-50" r="4" fill="white" stroke="#3b82f6" stroke-width="2"/>
                    <circle class="cursor-nesw gizmo-handle" data-type="scale" cx="50" cy="-50" r="4" fill="white" stroke="#3b82f6" stroke-width="2"/>
                    <circle class="cursor-nwse gizmo-handle" data-type="scale" cx="50" cy="50" r="4" fill="white" stroke="#3b82f6" stroke-width="2"/>
                    <circle class="cursor-nesw gizmo-handle" data-type="scale" cx="-50" cy="50" r="4" fill="white" stroke="#3b82f6" stroke-width="2"/>
                    
                    <!-- Rotate Handle -->
                    <line id="gizmoRotateLine" x1="0" y1="-50" x2="0" y2="-70" stroke="#3b82f6" stroke-width="1" />
                    <circle class="cursor-rotate gizmo-handle" data-type="rotate" cx="0" cy="-70" r="4" fill="#3b82f6" stroke="white" stroke-width="2"/>
                </g>

            </svg>
        </div>

        <p class="mt-8 text-gray-500 text-sm max-w-md text-center">
            Click element to activate gizmos. Drag to move. Use corners to scale.
        </p>

    </div>

    <!-- Hidden Canvas for Export -->
    <canvas id="exportCanvas" width="144" height="144" style="display:none;"></canvas>

    <script>
        // --- API Configuration ---
        const ICONIFY_SEARCH_URL = 'https://api.iconify.design/search?query=';
        const ICONIFY_SVG_URL = 'https://api.iconify.design/';

        // --- State Management ---
        const state = {
            border: {
                width: 8,
                radius: 24,
                style: 'rgb', 
                color1: '#ff4d4d',
                color2: '#4d4dff'
            },
            icon: {
                x: 72,
                y: 72,
                scale: 0.6,
                rotation: 0,
                overrideColor: false, 
                color: '#ffffff',
                type: 'default', // 'default', 'svg', 'image'
                content: null // Stores the original SVG string or Data URL
            },
            background: {
                color: '#000000',
                cornerFill: true,
                cornerColor: '#ffffff'
            },
            interaction: {
                isDragging: false,
                dragType: null, // 'move', 'scale', 'rotate'
                startX: 0,
                startY: 0,
                initialState: {}
            }
        };

        // --- DOM Elements ---
        const ui = {
            borderWidth: document.getElementById('borderWidth'),
            borderRadius: document.getElementById('borderRadius'),
            borderStyle: document.getElementById('borderStyle'),
            borderColor1: document.getElementById('borderColor1'),
            borderColor2: document.getElementById('borderColor2'),
            
            iconUpload: document.getElementById('iconUpload'),
            dropZone: document.getElementById('dropZone'),
            iconScale: document.getElementById('iconScale'),
            overrideColorToggle: document.getElementById('overrideColorToggle'),
            iconColor: document.getElementById('iconColor'),
            iconColorControl: document.getElementById('iconColorControl'),
            resetTransformBtn: document.getElementById('resetTransformBtn'),
            
            bgColor: document.getElementById('bgColor'),
            cornerFillToggle: document.getElementById('cornerFillToggle'),
            cornerColor: document.getElementById('cornerColor'),
            
            downloadBtn: document.getElementById('downloadBtn'),
            
            // New Search Elements
            iconSearchInput: document.getElementById('iconSearchInput'),
            iconSearchResults: document.getElementById('iconSearchResults'),
            iconResultsGrid: document.getElementById('iconResultsGrid'),
            searchMessage: document.getElementById('searchMessage'),
            
            // SVG Elements
            svg: document.getElementById('mainSvg'),
            bgRect: document.getElementById('bgRect'),
            borderRect: document.getElementById('borderRect'),
            gradient: document.getElementById('mainGradient'),
            stop1: document.getElementById('stop1'),
            stop2: document.getElementById('stop2'),
            
            transformGroup: document.getElementById('transformGroup'),
            iconGroup: document.getElementById('iconGroup'),
            
            gizmoLayer: document.getElementById('gizmoLayer'),
            gizmoBox: document.getElementById('gizmoBox'),
            gizmoRotateLine: document.getElementById('gizmoRotateLine'),
            snapX: document.getElementById('snapX'),
            snapY: document.getElementById('snapY'),
            
            cornerPath: document.getElementById('cornerPath'),
            clipRect: document.querySelector('#cornerRadiusClip rect'),
            floodColor: document.getElementById('floodColor')
        };
        
        // --- Utility Functions ---

        /**
         * Fetches a resource with exponential backoff for resilience.
         * @param {string} url - The URL to fetch.
         * @param {object} [options={}] - Fetch options.
         * @param {number} [maxRetries=5] - Maximum number of retries.
         */
        async function fetchWithBackoff(url, options = {}, maxRetries = 5) {
            let delay = 1000;
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        if (response.status >= 400 && response.status < 500) {
                            throw new Error(`Client Error: ${response.status} ${response.statusText}`);
                        }
                        throw new Error(`Server Error: ${response.status} ${response.statusText}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) {
                        console.error("Max retries reached. Failed to fetch:", url, error);
                        throw error;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
        }
        
        /**
         * Simple debouncing function.
         * @param {function} func - Function to debounce.
         * @param {number} delay - Delay in ms.
         */
        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }
        
        // --- Core Render Logic ---
        function render() {
            // Background
            ui.bgRect.setAttribute('fill', state.background.color);
            ui.bgRect.setAttribute('rx', state.border.radius);
            ui.clipRect.setAttribute('rx', state.border.radius);

            // Border
            ui.borderRect.setAttribute('stroke-width', state.border.width);
            const innerRadius = Math.max(0, state.border.radius - (state.border.width/2));
            ui.borderRect.setAttribute('rx', innerRadius);
            
            ui.borderRect.classList.remove('animate-rgb');
            if (state.border.style === 'solid') {
                ui.borderRect.setAttribute('stroke', state.border.color1);
            } else if (state.border.style === 'gradient') {
                ui.stop1.setAttribute('stop-color', state.border.color1);
                ui.stop2.setAttribute('stop-color', state.border.color2);
                ui.borderRect.setAttribute('stroke', 'url(#mainGradient)');
            } else if (state.border.style === 'rgb') {
                ui.stop1.setAttribute('stop-color', state.border.color1);
                ui.stop2.setAttribute('stop-color', state.border.color2);
                ui.borderRect.setAttribute('stroke', 'url(#mainGradient)');
                ui.borderRect.classList.add('animate-rgb');
            }

            // Icon Transform
            ui.transformGroup.setAttribute('transform', 
                `translate(${state.icon.x}, ${state.icon.y}) rotate(${state.icon.rotation}) scale(${state.icon.scale})`);

            // Icon Color & Filter Logic
            if(state.icon.overrideColor) {
                ui.iconColorControl.style.opacity = '1';
                ui.iconColorControl.style.pointerEvents = 'auto';
            } else {
                ui.iconColorControl.style.opacity = '0.5';
                ui.iconColorControl.style.pointerEvents = 'none';
            }

            // Apply SVG Fills / Reset Fills for SVGs if overrideColor is enabled/disabled
            const paths = ui.iconGroup.querySelectorAll('path, circle, rect, polygon, ellipse, line, polyline');
            if (state.icon.type === 'svg') {
                if (state.icon.overrideColor) {
                    paths.forEach(p => {
                        p.setAttribute('fill', state.icon.color);
                        if(p.getAttribute('stroke') && p.getAttribute('stroke') !== 'none') {
                             p.setAttribute('stroke', state.icon.color);
                        }
                    });
                } else if (state.icon.content) {
                    // Re-render original SVG to clear forced colors
                    const svgString = state.icon.content;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgString, 'image/svg+xml');
                    const svgEl = doc.querySelector('svg');
                    if(svgEl) {
                        svgEl.setAttribute('width', '100');
                        svgEl.setAttribute('height', '100');
                        svgEl.setAttribute('x', '-50');
                        svgEl.setAttribute('y', '-50');
                        ui.iconGroup.innerHTML = svgEl.outerHTML;
                    }
                }
            }


            // Apply Image Filters (PNG/Raster)
            const img = ui.iconGroup.querySelector('image');
            if (img) {
                if (state.icon.overrideColor) {
                    ui.floodColor.setAttribute('flood-color', state.icon.color);
                    img.setAttribute('filter', 'url(#colorizeFilter)');
                } else {
                    img.removeAttribute('filter');
                }
            }
            
            // Gizmo Visuals Update
            if(ui.gizmoLayer.parentNode !== ui.transformGroup) {
                ui.transformGroup.appendChild(ui.gizmoLayer);
            }
            ui.gizmoLayer.setAttribute('display', 'inline'); 
            
            // Corner
            ui.cornerPath.style.display = state.background.cornerFill ? 'block' : 'none';
            ui.cornerPath.setAttribute('fill', state.background.cornerColor);
        }
        
        // --- Interaction Logic (Gizmos) ---
        
        function getSvgPoint(evt) {
            const rect = ui.svg.getBoundingClientRect();
            const pt = ui.svg.createSVGPoint();
            pt.x = evt.clientX - rect.left;
            pt.y = evt.clientY - rect.top;
            
            // Scale point from display size (288/400px) to viewBox (144px)
            const scale = 144 / rect.width;
            pt.x *= scale;
            pt.y *= scale;
            return pt;
        }

        ui.svg.addEventListener('mousedown', (e) => {
            const pt = getSvgPoint(e);
            
            if(e.target.classList.contains('gizmo-handle')) {
                state.interaction.isDragging = true;
                state.interaction.dragType = e.target.dataset.type; // 'scale' or 'rotate'
                state.interaction.startX = pt.x;
                state.interaction.startY = pt.y;
                state.interaction.initialState = {...state.icon};
                e.stopPropagation();
                return;
            }
            
            if(ui.transformGroup.contains(e.target) || e.target.id === 'bgRect' || e.target.id === 'canvasContainer') {
                 state.interaction.isDragging = true;
                 state.interaction.dragType = 'move';
                 state.interaction.startX = pt.x;
                 state.interaction.startY = pt.y;
                 state.interaction.initialState = {...state.icon};
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (!state.interaction.isDragging) return;
            e.preventDefault();
            
            const pt = getSvgPoint(e);
            const initial = state.interaction.initialState;
            
            if (state.interaction.dragType === 'move') {
                let dx = pt.x - state.interaction.startX;
                let dy = pt.y - state.interaction.startY;
                
                let newX = initial.x + dx;
                let newY = initial.y + dy;
                
                // Snap Logic (Magnet)
                const snapThresh = 5;
                let snappedX = false;
                let snappedY = false;
                
                if (Math.abs(newX - 72) < snapThresh) {
                    newX = 72;
                    snappedX = true;
                }
                if (Math.abs(newY - 72) < snapThresh) {
                    newY = 72;
                    snappedY = true;
                }
                
                ui.snapX.setAttribute('opacity', snappedX ? 0.8 : 0);
                ui.snapY.setAttribute('opacity', snappedY ? 0.8 : 0);

                state.icon.x = newX;
                state.icon.y = newY;
                
            } else if (state.interaction.dragType === 'scale') {
                const dy = (state.interaction.startY - pt.y) * 0.01;
                let newScale = Math.max(0.1, initial.scale + dy);
                state.icon.scale = newScale;
                ui.iconScale.value = newScale;
                
            } else if (state.interaction.dragType === 'rotate') {
                const cx = state.icon.x;
                const cy = state.icon.y;
                
                const angle = Math.atan2(pt.y - cy, pt.x - cx) * 180 / Math.PI;
                state.icon.rotation = angle + 90; 
            }
            
            render();
        });

        window.addEventListener('mouseup', () => {
            state.interaction.isDragging = false;
            state.interaction.dragType = null;
            ui.snapX.setAttribute('opacity', 0);
            ui.snapY.setAttribute('opacity', 0);
        });

        // --- Icon Search Logic ---
        
        async function loadIconifyIcon(iconName) {
            try {
                const url = `${ICONIFY_SVG_URL}${iconName}.svg`;
                const response = await fetchWithBackoff(url);
                const svgString = await response.text();
                
                state.icon.type = 'svg';
                state.icon.content = svgString;
                loadSvgContent(svgString);
                
                // Reset search view
                ui.iconSearchResults.classList.add('hidden');
                ui.iconSearchInput.value = '';
                
            } catch (error) {
                console.error("Failed to load icon:", error);
                ui.searchMessage.textContent = "Error loading icon. Check console.";
            }
        }
        
        function displaySearchResults(icons) {
            ui.iconResultsGrid.innerHTML = '';
            ui.iconSearchResults.classList.remove('hidden');

            if (icons.length === 0) {
                ui.searchMessage.textContent = "No icons found for your query.";
                ui.searchMessage.classList.remove('hidden');
                return;
            }

            ui.searchMessage.classList.add('hidden');

            icons.forEach(icon => {
                const iconName = icon.icon;
                
                // Create a div wrapper for the icon and add class for styling
                const wrapper = document.createElement('div');
                wrapper.className = 'icon-result';
                wrapper.title = iconName;
                wrapper.dataset.iconName = iconName;

                // Create an image element to load the SVG preview
                const svgPreviewUrl = `${ICONIFY_SVG_URL}${iconName}.svg?width=32&height=32`;
                const img = document.createElement('img');
                img.src = svgPreviewUrl;
                img.alt = iconName;
                img.width = 32;
                img.height = 32;
                
                wrapper.appendChild(img);
                
                // Add click handler to the wrapper
                wrapper.addEventListener('click', () => loadIconifyIcon(iconName));
                
                ui.iconResultsGrid.appendChild(wrapper);
            });
        }
        
        const performSearch = debounce(async (query) => {
            if (query.length < 2) {
                ui.iconResultsGrid.innerHTML = '';
                ui.searchMessage.textContent = "Start typing to see results...";
                ui.searchMessage.classList.remove('hidden');
                ui.iconSearchResults.classList.add('hidden');
                return;
            }

            ui.iconResultsGrid.innerHTML = `<div class="col-span-5 flex justify-center py-2"><div class="loading-icon"></div></div>`;
            ui.iconSearchResults.classList.remove('hidden');
            ui.searchMessage.classList.add('hidden');

            try {
                const url = `${ICONIFY_SEARCH_URL}${encodeURIComponent(query)}&limit=20`;
                const response = await fetchWithBackoff(url);
                const data = await response.json();
                
                displaySearchResults(data.icons || []);
            } catch (error) {
                console.error("Iconify Search Failed:", error);
                ui.iconResultsGrid.innerHTML = '';
                ui.searchMessage.textContent = "Search failed. Try a simpler query.";
                ui.searchMessage.classList.remove('hidden');
            }
        }, 300);

        ui.iconSearchInput.addEventListener('input', (e) => performSearch(e.target.value.trim()));

        // --- Standard UI Bindings & File Handling ---
        function bind(elem, stateObj, key, renderFn = true) {
            elem.addEventListener('input', (e) => {
                let val = e.target.type === 'checkbox' ? e.target.checked : e.target.value;
                if(e.target.type === 'range') val = parseFloat(val);
                stateObj[key] = val;
                
                if(key === 'overrideColor' && state.icon.type === 'svg' && !val) {
                    // This re-renders with original SVG colors
                    loadSvgContent(state.icon.content); 
                } else if (key === 'overrideColor' && state.icon.type === 'svg' && val) {
                    // Force a render to apply color tint
                    render();
                }
                
                if(renderFn) render();
            });
        }

        bind(ui.borderWidth, state.border, 'width');
        bind(ui.borderRadius, state.border, 'radius');
        bind(ui.borderStyle, state.border, 'style');
        bind(ui.borderColor1, state.border, 'color1');
        bind(ui.borderColor2, state.border, 'color2');

        bind(ui.iconScale, state.icon, 'scale');
        bind(ui.overrideColorToggle, state.icon, 'overrideColor');
        bind(ui.iconColor, state.icon, 'color');
        
        ui.resetTransformBtn.addEventListener('click', () => {
            state.icon.x = 72;
            state.icon.y = 72;
            state.icon.rotation = 0;
            render();
        });

        bind(ui.bgColor, state.background, 'color');
        bind(ui.cornerFillToggle, state.background, 'cornerFill');
        bind(ui.cornerColor, state.background, 'cornerColor');

        function handleFile(file) {
            if(!file) return;
            const reader = new FileReader();
            
            if (file.type.includes('svg')) {
                reader.onload = (e) => {
                    state.icon.type = 'svg';
                    state.icon.content = e.target.result; 
                    loadSvgContent(e.target.result);
                };
                reader.readAsText(file);
            } else {
                reader.onload = (e) => {
                    state.icon.type = 'image';
                    state.icon.content = e.target.result;
                    loadImageContent(e.target.result);
                };
                reader.readAsDataURL(file);
            }
            // Clear search when file is uploaded
            ui.iconSearchResults.classList.add('hidden');
            ui.iconSearchInput.value = '';
        }

        function loadSvgContent(svgString) {
            const parser = new DOMParser();
            const doc = parser.parseFromString(svgString, 'image/svg+xml');
            const svgEl = doc.querySelector('svg');
            if(svgEl) {
                // Ensure the SVG fits nicely
                svgEl.setAttribute('width', '100');
                svgEl.setAttribute('height', '100');
                svgEl.setAttribute('x', '-50');
                svgEl.setAttribute('y', '-50');
                svgEl.setAttribute('overflow', 'visible'); 
                ui.iconGroup.innerHTML = svgEl.outerHTML; 
                render(); // Render handles color tinting if override is on
            } else {
                console.error("Failed to parse SVG content.");
            }
        }

        function loadImageContent(dataUrl) {
            ui.iconGroup.innerHTML = `<image href="${dataUrl}" x="-50" y="-50" width="100" height="100" preserveAspectRatio="xMidYMid meet" />`;
            render();
        }

        ui.iconUpload.addEventListener('change', (e) => handleFile(e.target.files[0]));
        ui.dropZone.addEventListener('click', () => ui.iconUpload.click());
        ui.dropZone.addEventListener('dragover', (e) => { e.preventDefault(); ui.dropZone.classList.add('dragover'); });
        ui.dropZone.addEventListener('dragleave', () => ui.dropZone.classList.remove('dragover'));
        ui.dropZone.addEventListener('drop', (e) => {
            e.preventDefault(); ui.dropZone.classList.remove('dragover'); handleFile(e.dataTransfer.files[0]);
        });
        window.toggleAccordion = (id) => {
            const el = document.getElementById(id);
            el.classList.toggle('open');
        };

        // --- Export ---
        ui.downloadBtn.addEventListener('click', () => {
            ui.gizmoLayer.setAttribute('display', 'none');
            
            const canvas = document.getElementById('exportCanvas');
            const ctx = canvas.getContext('2d');
            
            // Re-render SVG without gizmos, and with current styling applied
            const paths = ui.iconGroup.querySelectorAll('path, circle, rect, polygon, ellipse, line, polyline');
            if (state.icon.type === 'svg' && state.icon.overrideColor) {
                 // Force colors onto SVG elements for export if override is active
                 paths.forEach(p => {
                    p.setAttribute('fill', state.icon.color);
                    if(p.getAttribute('stroke') && p.getAttribute('stroke') !== 'none') {
                         p.setAttribute('stroke', state.icon.color);
                    }
                });
            }
            // Temporarily update border to solid color if RGB animation is on, so export is consistent
            const originalStroke = ui.borderRect.getAttribute('stroke');
            const originalClass = ui.borderRect.className;
            let tempColor = null;

            if (state.border.style === 'rgb' || state.border.style === 'gradient') {
                tempColor = state.border.color1; // Use color 1 as a solid representation
                ui.borderRect.setAttribute('stroke', tempColor);
                ui.borderRect.classList.remove('animate-rgb');
            }

            const svgData = new XMLSerializer().serializeToString(ui.svg);

            // Restore live view state
            if (tempColor) {
                ui.borderRect.setAttribute('stroke', originalStroke);
                ui.borderRect.className = originalClass; // Restores animate-rgb if it was there
            }
            ui.gizmoLayer.setAttribute('display', 'inline');

            const img = new Image();
            const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
            const url = URL.createObjectURL(svgBlob);

            img.onload = function() {
                ctx.clearRect(0, 0, 144, 144);
                ctx.drawImage(img, 0, 0, 144, 144);
                const pngUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = pngUrl;
                link.download = 'streamdeck-icon.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                // A quick final render to ensure the visual state is correct after temporary export changes
                render(); 
            };
            img.src = url;
        });

        // Init
        render();

    </script>
</body>
</html>
